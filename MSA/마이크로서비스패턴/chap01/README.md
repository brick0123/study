# 모놀리스 지옥에서 벗어나기

### 모놀리스의 장점

- `간편 하다`: 구성이 간편하고 손쉽게 개발할 수 있다.
- `쉬운 배포`: jar, war등으로 손쉽게 애플리케이션을 실행할 수 있다.
- `쉬운 테스트`: 하나의 애플리케이션에서 손쉽게 데이터, 로직을 이용해서 테스트할 수 있다.

### 모놀리스의 단점

- `스파게티 코드`: 코드를 잘 짠다고 하더라도, 규모가 점점 커질 수록 복잡도는 올라가서 난해해진다.
- `느린 생산성`: 애플리케이션이 거대해질 수록 소스코드를 컴파일 하는 시간이 올라가고, 메모리를 많이 잡아먹게 되고 IDE 실행 속도 역시 느려진다. 당연히 빌드하는 시간, 테스트 실행 속도가 느려진다. 이는 계속 악화된다.
- `확장하기 어렵다`: 필요한 특정 기능 확장, 리소스를 배분하는 것이 힘들다.
- `높은 장애 발생 가능성`: 하나의 프로세스로 실행되면서 장애결함이 되지않는다. 특정 모듈이나 기능에서 장애를 발생하게 한다면 시스템 전체의 문제가 발생할 수 있다.

# 마이크로 서비스가 답이다

![image](https://user-images.githubusercontent.com/61832162/157371206-472438fc-d667-4fe9-86a7-c05e7cb00150.png)


reference: [http://www.yes24.com/product/goods/86542732](http://www.yes24.com/product/goods/86542732)

- X축 확장 (다중 인스턴스에 요청 분산): 모놀리스 애플리케이션에서 일반적인 확장. 스케일 아웃 한 뒤, 로드 밸런서를 이용해서 요청을 분산한다.
- Z축 확장 (요청 속성별 라우팅): X축이랑 비슷하지만, 요청 속성에 따라 알맞는 인스턴스로 라우팅한다.
- **Y축 확장 (기능에 따른 애플리케이션을 서비스로 분해)**: X / Y축 만으로는 근본적인 모놀리스의 문제를 해결할 수 없다. 모놀리스 애플리케이션을 기능에 따른 여러 서비스로 분해하는 작업이다.

![image](https://user-images.githubusercontent.com/61832162/157371276-9b79190c-00a6-4594-a063-da1c7a06ee33.png)

reference: [http://www.yes24.com/product/goods/86542732](http://www.yes24.com/product/goods/86542732)

- 서비스마다 알맞게 X / Y축 확장이 가능하다. 마이크로서비스 아키텍처는 각 서비스가 집중된(응집된) 책임을 맞고 있는게 포인트다.
- 서비스 마다 DB가 따로 있다: 마이크로서비스는 느슨하게 결합되어 있고 서로 API를 통해서 통신한다. 이런 느슨한 결합된 서비스는 각각의 DB를 갖고 있다.

!![image](https://user-images.githubusercontent.com/61832162/157371310-f8c9c717-77be-4cbd-8702-cee5809874c5.png)


모놀리스
reference:[http://www.yes24.com/product/goods/86542732](http://www.yes24.com/product/goods/86542732)

![image](https://user-images.githubusercontent.com/61832162/157371384-c36873eb-21e0-4486-9794-2554991e07f8.png)

마이크로서비스
reference: [http://www.yes24.com/product/goods/86542732](http://www.yes24.com/product/goods/86542732)

# MSA 장단점

장점

- **장애 격리**: 독립적인 서비스 단위로 실행되므로, 장애가 격리되며, 신속하게 대응할 수 있다.
- **향상된 CI / CD**: 작은 서비스 단위로 운영하기 때문에 수시로 빠른 통합, 배포가 가능하다.
- **다양한 기술**: 서비스간 기술에 구애받지 않고, 자유로운 기술 스택을 사용할 수 있다.
- **확장성**: 원하는 서비스 단위로 상황에 맞게 신속하게 sacle-in, scale-out이 가능하다.

단점

- 난이도가 어려우며 비용이 많이 들어간다.

![image](https://user-images.githubusercontent.com/61832162/157371436-823502c1-40b4-412f-a9d3-00f86d3e1aff.png)

reference: [http://www.yes24.com/product/goods/86542732](http://www.yes24.com/product/goods/86542732)

# 패턴

### 통신 패턴

- 통신 스타일: 어떤 종류의 IPC?
- 디스커버리: 인스턴스 IP를 어떻게 찾아낼 것인가?
- 신뢰성: 서비스 불능 시 서비스간 신뢰성 어떻게 보장?
- 트랜잭셔널 메시징: DB 트랜잭션에 메세지 송신, 이벤트 발행 어떻게 통합?
- 외부 API: 클라이언트와 서비스와 어떻게 통신?

### 데이터 일관성 패턴

분산 트랜잭션을 처리하기 위해 기존에 `2PC` 방법 보다는 최근에는  `Saga` 패턴을 이용해서 데이터 일관성을 유지한다.

### 데이터 쿼리 패턴

서비스마다 각각의 DB를 갖고 있으면, 조인을 이용할 수 없다. 다음 두 가지 패턴 중 하나를 이용해서 여러 서비스에 흩어진 데이터를 조회한다.

- API 조합: 하나 이상의 서비스를 호출해서 결과 조합
- CQRS: 하나 이상의 데이터 레플리카를 유지해서 쉽게 쿼리

### 관측성 패턴

msa 환경에서는 요청 → 응답까지의 프로세스의 과정을 알기 쉽지 않다. 관측 가능한 서비스를 설계하려면 다음과 같은 패턴이 필요하다.

- 헬스 체크: 서비스의 상태를 점검
- 로그 수집: 서비스 내역을 기록하고, 로그를 검색할 수 있어야한다.
- 분산 추적: 각 외부 요청마다 ID를 부여하고, IPC를 트레이싱 한다.
- 예외 추적: 예외가 발생하면 추적 서비스에 보고.
- 애플리케이션 지표: 메트릭을 수집하고 서버에 표츌함

### 보안 패턴

MSA에서는 일반적으로 API 게이트웨이가 인증을 한 후 사용자 정보를 호출한 서비스에 전달. 일반적으로 JWT를 발급한다. 해당 토큰을 서비스에 건내고 인가를 확인한다.

---

# 추가 질문

## - SOA vs MSA

![image](https://user-images.githubusercontent.com/61832162/157371484-310c8b14-1297-4b8f-8366-cc16ee8e41bf.png)

Reference: [https://rubygarage.org/blog/monolith-soa-microservices-serverless](https://rubygarage.org/blog/monolith-soa-microservices-serverless)

### SOA

SOA(Service-Oriented Architecture)는 서비스 인터페이스를 활용해서 소프트웨어 컴포넌트의 `재사용`을 가능하게 만드는 설계.

SOA는 이론적으로 `ESB` 없이 구현할 수 있지만, 애플리케이션 각각 서비스를 노출하는 방법을 찾아야하며, 매우 힘든 작업이 된다.

### 차이점

## 여기서 분할을 결정해야 할 시점은 언제일까?

회사의 규모 등에 따라 매우 다를 것 같다. 마이크로서비스의 큰 이점 중 대표적으로 장애 격리, 애자일 개발 등을 뽑을 수 있을 거 같다. 반대로 단점이라고 하면 그만한 개발 자원이 필요한 것인데, 현실적으로 msa 관리가 쉽지 않다. 그렇기 때문에 msa 전환 도중 실패하는 사례가 많다고 들었다. 현실적으로 잘 고려해서 트레이드 오프를 해야 된다고 생각한다.

### MSA 전환을 어디서부터 시작해야할까?

회사 도메인에 따라 핵심 그리고 독립적으로 존재해야될 필요성이 느껴지는 도메인부터 진행을 하는 것이 좋지 않을까 라는 생각을 한다.

### z축 분할이 이론적으로는 괜찮아보이는데 실제 비즈니스에서도 맞을까?

데이터가 굉장히 많이 쌓이면 샤딩을 고려해볼 수 있을 거 같다.

### 실제 저 패턴 언어를 실무에서 사용할까

어떤 패턴을 구체적으로 얘기하는 지 모르겠지만, 대부분 msa 환경에서 필요하다고 생각한다.

### SOA와 MSA 의 프로토콜을 구분하는 경량화된 프로토콜의 기준은 무엇일까?

통신 프로토콜을 얘기하는 것이면 SOA같은 경우 WSDL, MSA는 다소 가벼운 REST,  gRPC를 이용해서 통신한다.

### MSA로 구현되면 독립적인 배포가 가능하지만 전체적인 서비스에서는 독립적인 배포가 의미가 있을까?

독립적인 서비스 배포는 의미가 있다. 우선 모놀리틱 서비스에서 배포는 코드가 많아질수록 시간이 많이 소요된다. 그렇게 때문에 기능을 빠르게 배포하거나 장애가 났을 시 롤백하는 시간이 영향이 있을 수 있다. 그리고 특정 서비스만 독립적으로 스케일 아웃을 진행할 수 있기 때문에 독립적인 배포는 의미가 크다.

## Reference

- [https://www.redhat.com/ko/topics/cloud-native-apps/what-is-service-oriented-architecture](https://www.redhat.com/ko/topics/cloud-native-apps/what-is-service-oriented-architecture)
- [https://www.ibm.com/kr-ko/cloud/learn/soa](https://www.ibm.com/kr-ko/cloud/learn/soa)
- [http://www.yes24.com/product/goods/86542732](http://www.yes24.com/product/goods/86542732)