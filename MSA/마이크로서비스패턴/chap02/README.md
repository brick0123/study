# ch02

# 분해 전략

---

### 소프트웨어 아키텍처란?

- 소프트웨어 엘리먼트와 그들간의 관계, 그리고 구성된 시스템을 추론하는데 필요한 구조

분해가 중요한 이유

- 전문성 분리: 전문 지식을 보유한 사람들이 팀을 이루어서 업무의 생산성이 올라간다.
- 상호 작용: 소프트웨어가 어떻게 상호작용 하는지 밝힌다.

### 소프트웨어 아키텍처 4+1 모델

애플리케이션 아키텍처를 보는 관점은 다양하다. 4+1 모델은 소프트웨어 아키텍처를 바라보는 상이한 4뷰를 정의한다.

각 뷰는 특정 측면을 기술하고 특정 소프트웨어 엘리먼트와 그들 사이의 관계로 구성된다.

- `논리` 뷰: 개발자가 작성한 소프트웨어 엘리먼트. ex) 클래스.
- `구현` 뷰: 빌드 시스템의 결과물. ex) jar, war (정적 의존 관계)
- `프로세스` 뷰: 런타임 컴포넌트. 각 엘리먼트는 개별 프로세스고, IPC는 프로세스간 관계를 나타냄
- `배포` 뷰: 프로세스가 머신에 매핑되는 방법. 이 뷰의 엘리먼트는(물리 또는 가상) 머신 및 프로세스고, 머신간의 관계가 네트워킹이다. 프로세스와 머신 사이의 관계도 이 뷰에서 기술됨.
- `시나리오` : 유스 케이스, 시나리오를 이용해서 설명.  개체 간 및 프로세스간 상효 작용을 설명.

![image](https://user-images.githubusercontent.com/61832162/157371693-1ad48839-e74a-44cd-a992-357f897260cf.png)

reference: [https://wiki.cantara.no/display/dev/4+plus+1+View+Model](https://wiki.cantara.no/display/dev/4+plus+1+View+Model)

## 아키텍처 스타일 개요

### 계층화 아키텍처

![image](https://user-images.githubusercontent.com/61832162/157371724-375a1957-051f-4687-a151-227cbe58bedc.png)

Reference: [https://www.baeldung.com/cs/layered-architecture](https://www.baeldung.com/cs/layered-architecture)

소프트웨어 엘리먼트를 계층별로 구성하는 대표적인 아키텍처(**layered** architecture). 계층화 아키텍처는 4뷰를 모두 적용 할 수 있다. 3계층 아키텍쳐는 계층화 아키텍처를 논리 뷰에 적용한 것이다. 애플리케이션 클래스를 다음 세 계층으로 구성한 아키텍처.

- **표현** 계층 (presentation): 사용자 인터페이스 또는 외부 API가 구현된 계층
- **비즈니스** 계층: 비즈니스 로직
- **영속화** 계층 (persistence): DB 상호 작용 로직

계층화 아키텍처의 **단점** 

- 표현 계층이 하나: 애플리케이션을 호출하는 시스템이 하나밖에 없을까?
- 영속화 계층이 하나: 애플리케이션이 상호 작용하는 DB가 정말 하나뿐인가?
- 비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다: 이론적으로 이런 디펜던시 때문에 DB 없이 비즈니스 로직을 테스트 하는 것은 불가능하다.

### 육각형 아키텍처

![image](https://user-images.githubusercontent.com/61832162/157371784-db6bf2d5-c9c5-4536-99a6-2e8bcdaea0c7.png)

Reference: [https://medium.com/idealo-tech-blog/hexagonal-ports-adapters-architecture-e3617bcf00a0](https://medium.com/idealo-tech-blog/hexagonal-ports-adapters-architecture-e3617bcf00a0)

육각형 아키텍처는 논리 뷰를 비즈니스 로직 중심으로 구성하는 계층화 아키텍처의 대안. 애플리케이 션에 표현 계층 대신 비즈니스 로직을 호출하여, 외부에서 들어온 요청을 처리하는 인바운드 어댑터와 영속화 계층 대신 비즈니스 로직에 의해 호출되고 외부 애플리케이션을 호출하는 아웃바운드 어댑터를 둔다.

비즈니스 로직이 어댑터에 의존하지 않는것이 이 아키텍처의 핵심이다. 어댑터가 비즈니스 로직에 의존한다.

비즈니스 로직에는 하나 이상 **`포트`**가 있다. 포트는 비즈니스 로직이 자신의 외부 세계와 상호 작용하는 방법이 정의된 작업이다. 포트는 **`인바운드`**, **`아웃바운드`**가 있다. 외부 애플리케이션은 인바운드 포트를 호출한다. 아웃바운드 포트는 비즈니스 로직이 외부 시스템을 호출하는 방법에 관한 것.

### 마이크로서비스도 아키텍처 스타일이다.

모놀리식 아키텍처는 구현뷰를 단일 컴포넌트로 구현한 아키텍처 스타일이다. 모놀리식 애플리케이션은 육각형 아키텍처 방식으로 구성한 논리 뷰를 가질 수 없다.

마이크로서비스 아키텍처는 구현 뷰를 다수의 컴포넌트로 구성한다. 컴포넌트는 서비스고 각 서비스는 자체 논리 뷰를 갖고 있다. 전형적인 육각형 아키텍처다.

### 서비스란?

독립적으로 배포 가능한 소프트웨어 컴포넌트. 서비스 API는 내부 구현을 캡슐화한다.
API는 서비스에 구현된 비즈니스 로직과 소통하는 어댑터를 이용해서 구현한다. 작업 어댑터는 비즈니스 로직을 호출하고 이벤트 어댑터는 비즈니스 로직이 내어준 이벤트 발행.

- **느슨한 결합**: 서로 API를 통해서 통신한다.
- 공유 라이브러리: 코드의 중복을 줄이는 것은 좋지만, 서비스간 결합도가 높아질 수 있으므로 조심해야한다.
- **서비스 규모는 중요하지 않다**: 크기 보다는, 팀의 효율성, 협동하는 부분을 최소로 하여 개발 가능한 서비스를 설계해야 한다.

---

## 마이크로서비스 아키텍처의 정의

아키텍처 정의 순서

1. 애플리케이션 요건을 핵심 요청으로 추출 하는 것. (특정 기술이 아닌, 추상적)
2. 어떻게 여러 서비스로 분리할지. (비즈니스 성격에 따라, DDD 하위 도메인별 구성...)
3. 서비스별 API 정의 (1단계 식별된 시스템 작업을 각 서비스에 배정해야함)

### 시스템 식별 작업

가장 첫번째는 시스템 작업을 정의하는 일이다. 그 출발점은 사용자 스토리 등을 이용하는 것이다.

- 1단계: 고수준 도메인 모델 정의
- 2단계: 기능 요건을 도출해서 도메인 모델로 정의한다.

### 고수준 도메인 모델 생성

주문하기 스토리는 다음과 같이 다양한 사용자 시나리오로 확장시킬 수 있다.

**given**

- 소비자가 있다
- 음식점이 있다
- 음식점은 소비자의 주소로 음식을 배달할 수 있다.
- 주문 총액이 음식점 최소 주문 금액에 부합하낟

**when**

- 소비자가 음식점에 주문한다

**then**

- 소비자 신용카드가 승인된다
- 주문이 PENDING_ACCEPTANCE 상태로 생성된다
- 생성된 주문이 소비자랑 연관된다
- 생성된 주문이 음식점과 연관된다

해당 시나리오에서는 Consumer, Order, Restaurant, CreditCard 등이 필요하다.

### 시스템 작업 정의

- 커멘드: createOrder(), acceptOrder()...
- 쿼리: gerOrder()... getMenu()

## 비즈니스  능력 패턴별 분해

조직의 목표, 구조 등을 분석해서 식별한다. 비즈니스 능력은 여러개의 하위 능력으로 분해할 수 있다.

상위능력의 하위 능력은 반드시 하나의 서비스로 묶이지 않는다. 성격이 다르면 각각 다른 서비스에 매핑된다.

---

## 서비스 분해 장애물

### 네트워크 지연

- 서비스를 여러개로 분산하면 그만큼 네트워크 통신도 더 많이 발생한다.

### 동기 IPC로 인한 가용성 저하

- REST API로 서비스를 간단하게 호출할 수 있지만, 서비스가 불능이 되는 경우 가용성이 떨어지는 문제가 생긴다. 비동기 메세징 처리를 이용해서 가용성을 높일 수 있다.

### 데이터 일관성

- 여러 서비스의 데이터 일관성이 맞추는 작업이 필요하다.  기존에는 2PC 방식을 많이 사용했지만, 요즘은 `saga` 패턴을 이용해서 트랜잭션을 관리한다.

### 일관된 데이터 뷰 확보?

- 데이터 애그리게이션을 뜻하는건가?

### 만능 클래스

일반적으로 Order를 예로 들어보자. Order는 주문과 관련된 모든 시스템에 연관이 되어있을 수 있다.
Order 클래스는 점점 커지고, 복잡해지며 msa 분해의 걸림돌이 될 수 있다.

해결책: DDD를 적용해서 각 서비스 자체 도메인 모델을 갖고 있는, 개별 하위 도메인으로 취급하는 것이다.
즉 주문과 연관된 서비스는 각자 버전의 Order 클래스를 가진 모델을 만든다.

ex) Order → Address, Restaurant ...

---

## 서비스 API 정의

이제 각 서비스별 API를 정의하고 어떻게 협력할 것인지 기술한다.

---

### Reference

- [http://www.yes24.com/product/goods/86542732](http://www.yes24.com/product/goods/86542732)
- [https://www.youtube.com/watch?v=TdyOH1xZpT8](https://www.youtube.com/watch?v=TdyOH1xZpT8)
- [https://engineering.linecorp.com/ko/blog/port-and-adapter-architecture/](https://engineering.linecorp.com/ko/blog/port-and-adapter-architecture/)