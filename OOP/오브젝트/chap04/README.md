# 설계 품질과 트레이드 오프

역할은 책임의 집합이기 때문에 책임이 적절하지 못하면 역할 역시 협력과 조화를 이루지 못한다. 결국 책임이 객체지향 애플리케이션 전체 품질을 결정한다.

객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다. 이 정의에는 객체지향 설계에 관한 두 가지 관점이 섞여있다. 1.객체지향 설계의 핵심이 책임이다. 
2. 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관돼 있다는 것이다.

설계는 변경을 위해 존재하고 변경에는 어떤식이든 비용이 발생한다. 훌룡한 설계란 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것이다. 적절한 비용 안에서 쉽게 변경할 수 있는 설계는 응집도가 높고 서로 느슨하게 결합돼 있는 요소로 구성됨.

결합도와 응집도를 유지할 수 있는 중요한 원칙이 있다. 객체의 상태가 아닌 행동의 초점을 맞추는 것이다. 객체를 단순한 데이터의 집합으로 바라보는 시각은 객체의 내부 구현을 퍼블릭 인터페이스에 노출시키는 결과를 낳기 때문에 결과적으로 설계가 변경에 취약해진다.

## 데이터 중심의 영화 예매 시스템

데이터 중심의 관점에서 객체는 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의한다. 책임 중심의 관점에서는 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관한다. 전자는 객체를 독립된 데이터 덩어리로 바라보고 후자는 객체를 협력하는 공동체의 일원으로 바라본다.

후자가 훌룡한 객체지향 설계와 관계가 있다. 이유는 변경과 관련이 있다.

객체의 상태는 구현에 속한다. 구현은 불안정하기 때문에 변경되기 쉽다. 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들기 되어 캡슐화의 원칙이 무너진다. 결과적으로 상태 변경은 인터페이스의 변경을 초래하며 이 인터페이스에 의존하는 모든 변경의 영향이 퍼지게 된다. 따라서 데이터에 초점을 맞추는 설계는 변경에 취약할 수 밖에 없다.

그에 비해 책임은 인터페이스에 속한다. 객체는 책임을 드러내는 인터페이스를 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지함.

---

## 설계 트레이드오프

### 캡슐화

상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서다. 여기서 구현이란 나중에 변경될 가능성이 높은 어떤것을 가르킨다. 객체를 사용하면서 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있다.

변경될 가능성이 높은 부분을 `구현`이라 부르고 상대적으로 안정적인 부분을 `인터페이스`라고 부른다. 객체를 설계하기 위해 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이다.

캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다. 객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화 하는것이다.

### 응집도와 결합도

`응집도` 는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. 모듈 내의 요소들이 다른 목적을 추구한다면 그 모듈은 낮은 응집도를 가진다.

`결합도`는 의존성의 정도를 나타내며 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다. 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분을 알고 있다면 두 모듈은 높은 결합도를 가진다. 반대로 꼭 필요한 지식만 알고 있다면 낮은 결합도를 갖는다.

애플리케이션을 구성하는 각 요소의 응집도가 높고 서로 느슨하게 결합되어 있으면 좋은 설계를 가졌다고 말할 수 있다.

높은 응집도와 낮은 결합도는 변경하기 쉽게 만든다. 변경의 관점에서 응집도란 변경이 **발생할 때 모듈 내부에서 발생하는 변경의 정도**로 측정할 수 있다. 즉 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은 것이고 모듈의 일부분만 변경되면 응집도가 낮은것이다.

내부 구현을 변경했을 때 이것이 다른 모듈에 영향을 미치는 경우 두 모듈사이의 결합도가 높다고 표현한다. 반면 퍼블릭 인터페이스를 수정했을 때만 다른 모듈에 영향을 미치는 경우에는 결합도가 낮다고 표현한다.

---

## 자율적인 객체를 향해

### 캡슐화를 지켜라

객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야한다.

### 스스로 자신의 데이터를 책임지는 객체

상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서다. 객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.

따라서 객체를 설계할 때 “이 객체가 어떤 데이터를 포함해야 하는가?” 라는 질문은 다음과 같은 두 개의 개별 질문으로 분리해야한다.

- 이 객체가 어떤 데이터를 포함해야하나?
- 이 객체가 데이터에 대해 수행해야되는 오퍼레이션은 무엇인가?

두 질문을 조합하면 객체의 내부 상태를 저장하는 방식과 저장된 상태에 대해 호출할 수 있는 오퍼레이션의 집합을 얻을 수 있다.

---

### 데이터 중심 설계는 행동보다 상태에 초점을 맞춘다

데이터 중심 설계를 시작할때 “이 객체가 포함해야 하는 데이터가 무엇인가?”다. 데이터는 구현의 일부라는 것을 잊지 말자. 처음부터 데이터에 관해 결정하도록 강요하면 너무 이른 시기에 내부 구현에 초점을 맞추게 한다.