# chap01 & chap02

### 캡슐화와 응집도

핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다. 밀접하게 연관된 작업만 수행하고 **연관성 없는 작업은 다른 객체에게 위임**하는 객체를 `응집도`가 높다고 말할 수 있다.

객체간의 응집도를 높이려면 스스로 자신의 데이터를 책임지는 자율적인 존재여야한다. 외부의 간섭을 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌룡한 객체지향 설계의 지름길이다.

---

# Chap02 객체지향 프로그래밍

### 협력, 객체, 클래스

대부분의 사람들은 클래스를 결정한 후에 클래스에 어떤 속성과 메서드가 필요한지 고민한다. 하지만 이 방식은 객체지향의 본질과는 거리가 멀다.진정한 객체지향 패러다임은 클래스가 아닌 객체에 초첨을 맞출 때에만 얻을 수 있다.

1. 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라. 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다. 객체는 독립된 존재가 아니다. 다른 객체에게 도움을 주거나 의존하는 협력적인 존재다. 객체들의 모양과 윤곽이 잡히면 공통된 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현하라.

### 자율적인 객체

두 가지 중요한 사실이 있다.

- 상태와 행동을 함께 가지는 복합적인 존재
- 객체가 스스로 판단하고 행동하는 자율적인 존재

객체지향은 객체라는 단위 안에서 데이터와 기능을 한 덩어리로 묶어서 표현한다. 이처럼 데이터와 기능을 객체 내부로 함께 묶는 것을 `캡슐화`라한다.

객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다. 객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것이다. 객체가 자율적이려면 외부의 간섭을 최소화해야한다. 외부에서 객체가 어떤 상태에 놓여 있는지 알면 안 되고, 결정에 직접적으로 개입하려고 해서도 안 된다. 객체가 원하는 것을 요청하고 객체가 스스로 최선의 방법을 결정할 수 있을 거라는 점을 믿는다.

켑슐화와 접근 제어는 객체를 두 부분으로 나눈다.

1. **퍼블릭 인터페이스**: 외부에서 접근 가능한 부분
2. **구현**: 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분

일반적으로 객체의 상태는 숨기고 행동만 외부에 공개해야한다.

객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송 하는 것뿐이다. 다른 객체에게 요청이 도착할 때 해당 객체가 메시지를 수신했다고 이야기한다. 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다. 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드**라고 부른다.

## 상속과 다형성

### 컴파일 시간 의존성과 실행 시간 의존성

어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이의 의존성이 있다고 말한다.

컴파일 타임과 런타임 의존성이 다를 수 있으며 다르면 다를 수록 코드를 이해하기 어려워지지만, 더 유연해지고 확장 가능해진다.

### 상속과 인터페이스

상속은 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있는 장점이 있다.

인터페이스는 객체가 이해할 수 있는 메시지 목록을 정의한다는 것이 중요하다. 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다. 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에, 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.

### 다형성

클라이언트는 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. 이를 `다형성`이라한다.

다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성을 다를 수 있다는 사실을 기반으로한다. 다형성은 컴파일 시점 의존성과 런타임 시점 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해 서로 다른 메서드를 실행할 수 있다.

다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다. 따라서 다형적인 협력에 참여하는 객체는 모두 같은 메시지를 이해할 수 있어야한다. 

다형성을 구현하는 방법은 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정하는 공통점이 있다. 즉 메시지와 메서드를 실행 시점에 바인딩 한다는 것이다. 이를 `지연 바운딩` 또는 `동적 바운딩` 이라 한다.

상속을 이용하면 인터페이스를 공유하는 클래스들을 하나의 타입 계층으로 묶을 수 있다. 이런 이유로 보통 다형성을 이야기할 때 상속을 함께 언급한다. 그러나 클래스를 상속 받는 것만이 다형성을 구현할 수 있는 유일한 방법은 아니다.

### 인터페이스와 다형성

상속은 자식 클래스들이 인터페이스와 내부 구현을 함께 상속받도록 만들어졌다. 그러나 구현을 공유하지 않고 순수하게 인터페이스만 공유하고 싶을 때가 있다. 이를 위해 C#과 자바에서는 **인터페이스**를 제공한다. 자바의 인터페이스는 구현에 대한 고려 없어 다형적인 협럭에 참여하는 클래스들이 공유 가능한 외부 인터페이를 정의한 것이다.

## 추상화와 유연성

### 추상화의 힘

추상화를 사용할 경우 대표적으로 다음의 장점이 있다.

- 요구사항의 정책을 높은 수준에서 서술할 수 있다
- 추상화를 이용하면 설계가 좀 더 유연해진다.

추상화를 이용하면 세부적인 내용을 무시하고 상위 정책을 쉽고 간단하게 표현할 수 있다. 두 번째 특징은 첫 번째 특징에서 유추할 수 있다. 추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지도 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다. 다시 말해 유연한 설계를 가능하게 한다.

### 코드 재사용

상속은 코드를 재사용하기 위해 자주 사용된다. 그렇다고 가장 좋은 방법은 아니다. 보통 `합성`을 자주 사용하라라는 말이 있다. 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 얘기한다. 왜 그럴까?

### 상속

상속은은 객체지향에서 코드를 재사용하기 위해 널리 사용된다. 하지만 두 가지 관점에서 안 좋은 영향을 미친다.

- 캡슐화를 위반한다
- 상속을 이용하려면 부모 클래스의 내부 구조를 잘 알고 있어야한다.

결과적으로 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다. 캡슐화가 약화되는 자식 클래스가 부모 클래스에 **강하게 결합**되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 **변경될 확률을 높인다**. 결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워진다.

두번째로 설계가 유연하지 않다라는 것이다. 상속은 부모 클래스와 자식 클래스 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.

### 합성

합성은 상속의 두 가지 문제점을 모두 해결한다. 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다. 또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다. 상속 클래를 통해 강하게 결합되는 데 비해 합성은 메시지를 통해 느슨하게 결합된다.